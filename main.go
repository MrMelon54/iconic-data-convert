package main

import (
	"bufio"
	_ "embed"
	"encoding/json"
	"flag"
	rawJson "github.com/MrMelon54/iconic-data-convert/json"
	"github.com/MrMelon54/iconic-data-convert/scan-data"
	scan_modules "github.com/MrMelon54/iconic-data-convert/scan-modules"
	"github.com/MrMelon54/iconic-data-convert/scan-script"
	"log"
	"net/http"
	"os"
	"sort"
)

var iconicScriptPath, iconicDataPath, iconicDataOutPath, moduleOrderPath, rawModuleUrl string

func main() {
	flag.StringVar(&iconicScriptPath, "script", "iconicScript.cs", "iconicScript.cs file to parse")
	flag.StringVar(&iconicDataPath, "data", "iconicData.cs", "iconicData.cs file to parse")
	flag.StringVar(&iconicDataOutPath, "out", "iconicData.json", "iconicData.json file to output")
	flag.StringVar(&moduleOrderPath, "modules", "modules.txt", "modules.txt file containing all the modules in order")
	flag.StringVar(&rawModuleUrl, "raw", "https://ktane-mirror.mrmelon54.com/json/raw", "raw json module data")
	flag.Parse()

	rawModuleData, err := http.Get(rawModuleUrl)
	if err != nil {
		log.Fatal("Failed to download raw json data: ", err)
	}

	var repoRawJson rawJson.KtaneRawJson
	err = json.NewDecoder(rawModuleData.Body).Decode(&repoRawJson)
	if err != nil {
		log.Fatal("Failed to decode raw json data: ", err)
	}

	iconicScript, err := os.Open(iconicScriptPath)
	if err != nil {
		log.Fatal("Failed to open iconic script file: ", err)
	}
	iconicData, err := os.Open(iconicDataPath)
	if err != nil {
		log.Fatal("Failed to open iconic data file: ", err)
	}
	iconicOut, err := os.OpenFile(iconicDataOutPath, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)
	if err != nil {
		log.Fatal("Failed to open iconic output file: ", err)
	}
	orderFile, err := os.Open(moduleOrderPath)
	if err != nil {
		log.Fatal("Failed to open iconic modules file: ", err)
	}

	scriptScanner := bufio.NewScanner(iconicScript)
	scriptScanner.Split(bufio.ScanLines)
	dataScanner := bufio.NewScanner(iconicData)
	dataScanner.Split(bufio.ScanLines)
	outWriter := json.NewEncoder(iconicOut)
	outWriter.SetIndent("", "  ")
	orderScanner := bufio.NewScanner(orderFile)
	orderScanner.Split(bufio.ScanLines)

	log.Println("[INFO] Scanning modules.txt")
	moduleOrder := scan_modules.ScanIconicModules(log.Default(), orderScanner, repoRawJson)
	if err := orderFile.Close(); err != nil {
		log.Fatal("[ERROR] Failed to close modules.txt: ", err)
	}

	log.Println("[INFO] Scanning iconicScript.cs")
	moduleMap := scan_script.ScanIconicScript(log.Default(), scriptScanner)
	if err := iconicScript.Close(); err != nil {
		log.Fatal("[ERROR] Failed to close iconicScript.cs: ", err)
	}

	log.Println("[INFO] Scanning iconicData.cs")
	iconicModules := scan_data.ScanIconicData(log.Default(), dataScanner, moduleMap, moduleOrder, repoRawJson)
	if err := iconicData.Close(); err != nil {
		log.Fatal("[ERROR] Failed to close iconicData.cs: ", err)
	}

	sort.Slice(iconicModules, func(i, j int) bool {
		return iconicModules[i].Order < iconicModules[j].Order
	})

	if outWriter.Encode(rawJson.IconicData{
		Underscore: "Generated by KTaNE Iconic Editor. DO NOT EDIT.",
		Modules:    iconicModules,
	}) != nil {
		log.Fatal("[ERROR] Failed to write iconicData.json output: ", err)
	}
	if err := iconicOut.Close(); err != nil {
		log.Fatal("[ERROR] Failed to close iconicData.json: ", err)
	}
	log.Println("[INFO] Successfully wrote output file")
}
