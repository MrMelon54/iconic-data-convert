package main

import (
	"bufio"
	_ "embed"
	"encoding/json"
	"flag"
	"log"
	"os"
	"regexp"
	"strings"
)

var (
	reScript = regexp.MustCompile(`^{ "([^"]+)", iconicData\._([^ ]+) },$`)
	reData   = regexp.MustCompile(`^public static string\[] _([^ ]+) = {\s*"([^"]+)", ([^}]+)};$`)
	rePart   = regexp.MustCompile(`"([^"]+)",?\s*`)

	iconicScriptFile, iconicDataFile, iconicDataOut string

	cleanInvalidChars = strings.NewReplacer("░", " ", "▒", " ", "▓", " ", "█", " ", "═", " ", "║", " ")
)

func main() {
	flag.StringVar(&iconicScriptFile, "s", "iconicScript.cs", "iconicScript.cs file to parse")
	flag.StringVar(&iconicDataFile, "d", "iconicData.cs", "iconicData.cs file to parse")
	flag.StringVar(&iconicDataOut, "o", "iconicData.json", "iconicData.json file to output")
	flag.Parse()

	moduleMap := make(map[string]string)
	iconicModules := make([]IconicModule, 0)

	iconicScript, err := os.Open(iconicScriptFile)
	if err != nil {
		log.Fatal("Failed to open iconic script file: ", err)
	}
	iconicData, err := os.Open(iconicDataFile)
	if err != nil {
		log.Fatal("Failed to open iconic data file: ", err)
	}
	iconicOut, err := os.OpenFile(iconicDataOut, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)
	if err != nil {
		log.Fatal("Failed to open iconic output file: ", err)
	}

	scriptScanner := bufio.NewScanner(iconicScript)
	scriptScanner.Split(bufio.ScanLines)
	dataScanner := bufio.NewScanner(iconicData)
	dataScanner.Split(bufio.ScanLines)
	outWriter := json.NewEncoder(iconicOut)
	outWriter.SetIndent("", "  ")

	log.Println("[INFO] Scanning iconicScript.cs")
	scanIconicScript(scriptScanner, moduleMap)

	log.Println("[INFO] Scanning iconicData.cs")
	scanIconicData(dataScanner, moduleMap, &iconicModules)

	err = outWriter.Encode(IconicData{
		Underscore: "Generated by KTaNE Iconic Editor. DO NOT EDIT.",
		Modules:    iconicModules,
	})
	if err != nil {
		log.Fatal("[ERROR] Failed to write iconicData.json output: ", err)
	}
	log.Println("[INFO] Successfully wrote output file")
}

func scanIconicScript(s *bufio.Scanner, moduleMap map[string]string) {
	var running, ignoreLines bool
	for s.Scan() {
		a := strings.TrimSpace(s.Text())
		if ignoreLines {
			if a == "*/" {
				ignoreLines = false
			}
			continue
		}
		if !running {
			if strings.Contains(a, "private OrderedDictionary ModuleList = new OrderedDictionary {") {
				running = true
			}
			continue
		}
		if strings.Contains(a, "{ string.Empty, iconicData.BlankModule }") {
			break
		}
		if a == "" {
			continue
		}
		if a == "/*" {
			ignoreLines = true
			continue
		}

		b := reScript.FindStringSubmatch(a)
		if b == nil {
			log.Printf("[WARNING] Line didn't match: \"%s\"\n", a)
			continue
		}
		// map the variable to the string name
		moduleMap[b[2]] = b[1]
	}
	if err := s.Err(); err != nil {
		log.Fatal("[ERROR] Failed to parse iconic script: ", err)
	}
}

func scanIconicData(s *bufio.Scanner, moduleMap map[string]string, modules *[]IconicModule) {
	var running, ignoreLines bool
	for s.Scan() {
		a := strings.TrimSpace(s.Text())
		if ignoreLines {
			if a == "*/" {
				ignoreLines = false
			}
			continue
		}
		if !running {
			if strings.Contains(a, "public static string[] BlankModule") {
				running = true
			}
			continue
		}
		if a == "}" {
			break
		}
		if a == "" {
			continue
		}
		if a == "/*" {
			ignoreLines = true
			continue
		}

		b := reData.FindStringSubmatch(a)
		if b == nil {
			log.Printf("[WARNING] Line didn't match: \"%s\"\n", a)
			continue
		}
		if len(b) < 3 {
			log.Fatal("[ERROR] Regexp result is missing a value")
		}
		modVar, modParts := b[1], b[3]
		modRaw := cleanInvalidChars.Replace(b[2])

		partMatchSlice := rePart.FindAllStringSubmatch(modParts, -1)
		if partMatchSlice == nil {
			log.Printf("[WARNING] Failed to parse parts '%s'\n", modParts)
		}
		partSlice := make([]string, len(partMatchSlice))
		for i := range partSlice {
			partSlice[i] = partMatchSlice[i][1]
		}

		if modKey, ok := moduleMap[modVar]; ok {
			*modules = append(*modules, IconicModule{
				Key:   modKey,
				Raw:   modRaw,
				Parts: partSlice,
			})
		} else {
			log.Printf("[WARNING] Failed to find variable '_%s' in iconicScript.cs\n", modVar)
		}
	}
	if err := s.Err(); err != nil {
		log.Fatal("[ERROR] Failed to parse iconic script: ", err)
	}
}
